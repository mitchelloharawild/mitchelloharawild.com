{
  "hash": "b53aa5744364c3c17de38ee6c010f15c",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Why I refuse to add style options to my ggplot2 plot functions\ndescription: 'Designing plot helper and grammar extension functions for ggplot2, and how good design helps you make better plots.'\ndate: today\ncategories:\n  - ggplot2\n  - packages\ntags:\n  - cran\n  - package\n  - time series\nexecute:\n  cache: true\nimage-alt: 'Drawing of a package'\n---\n\n\n\n\n![](ggplot2.svg){class=\"hex\"}\n\n<!-- ## Can you add this? no! -->\n\nI develop many packages with functions that use [ggplot2](https://ggplot2.tidyverse.org/) to make a specific plot, and I'm often asked if I could add new arguments for changing the style, appearance, or layout of the plot. My answer is *almost always*^[The few times I have implemented these requests I later realise I shouldn't have.] a resounding ***no!***, followed by encouragement to make the plot themselves without the plot helper function.\n\n<!-- For example, changing the colour of the horizontal average lines in a seasonal subseries plot. -->\n\nThis outright refusal to implement easy plot *improvements* might surprise users and seem harsh - after all it is easy to add an argument for changing plot colours thanks to ggplot2's grammar-based design. \n\nWhy do I refuse to make these easy improvements?\nIt's a matter of design.\n\n<!-- along with some functions which extend ggplot2 with new geometries -->\n\n<!-- * asked to add new features for changing style / appearance of `autoplot()` or `gg_*()` functions - but I say no, why? (I've even asked myself to do this! https://github.com/tidyverts/feasts/issues/134), https://github.com/tidyverts/feasts/issues/109 -->\n\n<!-- * sometimes I have added arguments for changing the line colour, but later regret it (possibly introducing breaking changes through removing option). -->\n<!-- * these features are easy to add thanks to the grammar in ggplot2 - but it's hard to design a wrapper which exposes the grammar -->\n\n<!--- To understand what I mean by design, let me briefly cover two common ggplot2 design patterns --->\n\n## Design patterns of ggplot2 extensions\n\n*Extension*[^ext-gallery] functions of ggplot2 can be categorised into two distinct groups:\n\n[^ext-gallery]: I take semantic/pedantic issue with calling functions which use ggplot2 'extensions', and think this causes some design confusion among developers and users. Both function types appear in the ggplot2 [official *'extensions'* gallery](https://exts.ggplot2.tidyverse.org/gallery/), and consequently it is common for all ggplot2-related packages to be called extensions.\n\n1. Functions which *use* ggplot2 (plot helpers)\n   \n   These functions produce a specific plot with a single function, useful for quickly creating a common plot for the data or analysis.\n   \n   ::: {.callout-note title=\"Example: `autoplot()` for time-series plots\" collapse=\"true\"}\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   library(fable)\n   tsibble::as_tsibble(USAccDeaths) |> \n     autoplot(value)\n   ```\n   \n   ::: {.cell-output-display}\n   ![](index_files/figure-html/timeplot-1.png){width=672}\n   :::\n   :::\n\n   :::\n   \n2. Functions which *extend* ggplot2 (grammar extensions)\n\n   These functions add to the plotting grammar available in ggplot2, and are highly customisable and versatile. On their own, grammar extension functions don't produce plots but rather plot elements - plots are constructed using a combination of plot elements.\n\n   ::: {.callout-note title=\"Example: `ggrepel::geom_text_repel()`\" collapse=\"true\"}\n   \n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   library(ggrepel)\n   ggplot(mtcars, aes(wt, mpg, label = rownames(mtcars))) +\n     geom_text_repel() +\n     geom_point(color = 'red')\n   ```\n   \n   ::: {.cell-output-display}\n   ![](index_files/figure-html/textrepel-1.png){width=672}\n   :::\n   :::\n\n   :::\n\n<!-- Both types of functions are useful but serve different purposes, and therefore should have different software designs. -->\n\nPlot helpers and ggplot2 extension functions are both useful, but serve different purposes in an analysis <!-- workflow--->. The design tendency of doing too much can make these functions less useful for their purpose. In particular for ggplot2 extension packages, it is common to make plot helpers more extensible and ggplot2 extensions more helpful. \n\nWhy does this become a design problem? Read on...\n\n<!-- In many ggplot2 extension packages I see each group attempt to incorporate designs of the other. Plot helper functions that use ggplot2 attempt to add style customisation by exposing the grammar and single grammar extension functions attempt to do the work of many. -->\n\n<!-- TODO: Rephrase this paragraph, add emphasis on why I refuse for design purposes -->\n<!-- Aside: these design considerations apply not just to ggplot2 extensions but designing good composable abstractions and wrapper functions -->\n\n<!-- * in defence of plotting functions in the context of extending the grammar - many people dislike `autoplot()` and other single-plot helper functions, I disagree. -->\n\n<!-- Types of 'extensions' for ggplot2 -->\n\n<!-- * 'wrapper' functions which use ggplot2 -->\n\n<!-- * extensions of ggplot2 with ggproto -->\n\n### Plot helpers using ggplot2\n\nPlot helper functions use many ggplot2 elements together into a simple function for creating a specific graphic. These functions abstract away the grammar of graphics, and their design should focus on *what* is being plotted (the data and its patterns) rather than *how* (the geometries, aesthetic mappings, and more).\n\nTake for example the `feasts::gg_season()` function for plotting a seasonal plot of time-series data, which is commonly used in a time-series analysis to understand the shape of the seasonality (identifying peak times from throughs).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tsibble)\nas_tsibble(USAccDeaths) |> \n  feasts::gg_season(y = value)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/seasonplot-1.png){width=672}\n:::\n:::\n\n\nFunctions like these are really useful during an analysis, allowing a quick peek at the data without needing to repeatedly write the same grammar elements (expand below) each and every time.\n\n::: {.callout-note title=\"Reproduction of above plot without gg_season()\" collapse=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(lubridate)\ntsibble::as_tsibble(USAccDeaths) |> \n  ggplot(aes(x = month(index), y = value, colour = factor(year(index)))) + \n  geom_path() + \n  scale_x_continuous(breaks = 1:12, labels = month.abb) + \n  labs(y = \"Accidental deaths in the USA\", x = \"Month\", colour = \"Year\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/seasonplot-diy-1.png){width=672}\n:::\n:::\n\n\n:::\n\n<!-- The design of `gg_season()` highlights *what* is being visualised, with minimal options to change *how* the plot is made: -->\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- gg_season( -->\n<!--   data, -->\n<!--   y = NULL, -->\n<!--   period = NULL, -->\n<!--   facet_period = NULL, -->\n<!--   max_col = Inf, -->\n<!--   max_col_discrete = 7, -->\n<!--   pal = (scales::hue_pal())(9), -->\n<!--   polar = FALSE, -->\n<!--   labels = c(\"none\", \"left\", \"right\", \"both\"), -->\n<!--   labels_repel = FALSE, -->\n<!--   labels_left_nudge = 0, -->\n<!--   labels_right_nudge = 0, -->\n<!--   ... -->\n<!-- ) -->\n<!-- ``` -->\n\nThe handling of the x-axis wrapping and line grouping/colouring is combined/abstracted as the seasonal `period`. Similar plot-specific abstraction is done for faceting seasons with `facet_period` allowing for quick and informative plots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfill_gaps(pedestrian) |> \n  dplyr::filter(Sensor == \"Southern Cross Station\") |> \n  feasts::gg_season(y = Count, period = \"day\", facet_period = \"1 weeks\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/facetseasonplot-1.png){width=672}\n:::\n:::\n\n\n::: {.callout-note title=\"Reproduction of above plot without gg_season()\" collapse=\"true\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nlibrary(lubridate)\nfill_gaps(pedestrian) |> \n  dplyr::filter(Sensor == \"Southern Cross Station\") |> \n  ggplot(aes(x = hour(Date_Time), y = Count, colour = as.Date(Date_Time), group = as.Date(Date_Time))) + \n  geom_path() + \n  facet_grid(cols = vars(wday(Date_Time, label = TRUE, abbr = FALSE, week_start = 1))) + \n  scale_color_gradientn(colours = scales::hue_pal()(9), labels = \\(x) as.Date(x, origin = \"1970-01-01\")) +\n  labs(y = \"Pedestrians at Southern Cross Station\", x = \"Hour\", colour = \"Date\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/facetseasonplot-diy-1.png){width=672}\n:::\n:::\n\n\n:::\n\nWhile useful, these plots aren't the prettiest - they don't try to be. Seasonal plots as shown above are unlikely to be readily suitable for wider publication, and the necessary improvements aren't limited to the theme and style. A useful similar alternative is using box-plots rather than lines to more clearly show the typical number of pedestrians throughout the day. Creating beautiful publication ready graphics involves more than simply using a suitable chart type and variables, but also carefully considering the layout, colours, and typography^[For more details I highly recommend this 20 minute presentation - [*The Glamour of Graphics*](https://www.youtube.com/watch?v=h5cTacaWE6I) by [William Chase](https://www.williamrchase.com/)].\n\nBy not adding stylistic options to my plot helper functions, I hope to encourage users to think more creatively when constructing their visualisation. Not just using prettier colours or themes, but also creating more suitable chart types for better reader comprehension. After all, these plots are intended for experienced analysts to quickly preview important features of the data. They are aren't intended to be readily understood by an untrained reader.\n\n[Cynthia Huang](https://www.cynthiahqy.com/)'s companion blog post [*Layer arguments for ggplot2 wrapper functions*](https://www.cynthiahqy.com/posts/ggplot-wrapper-design) highlights the difficulty in creating plot helper functions which also expose the underlying grammar for further plot customisation. This design challenge is not specific to ggplot2 extensions, but more broadly applicable to any functions which abstract complexity away from underlying functions. The post offers a clever alternative that allows full plot customisation without adding countless style arguments which re-introduce complexity to an abstraction.\n\n<!-- Perhaps improve final message from this - possibly showing other helper functions which try to be extra helpful with many style arguments -->\n\n\n<!-- design difficulties of creating plot helper functions that also expose the grammar for further user customisation. -->\n\n<!-- Another reason against adding additional style arguments to plot helper functions was recently highlighted by Cynthia Huang -->\n\n\n\n<!-- * many *extensions* of ggplot2 actually just *use* ggplot2. Trying to expose the grammar makes the design of your plotting function worse, harder to learn, use, and maintain. -->\n\n<!-- * Why wrappers? it's easier. ggproto is hard? designing extensions is hard? -->\n\n<!-- * Refer to Cynthia's recent post highlighting 'grammar arguments' -->\n\n### Grammar extensions for ggplot2\n\nContrary to plot helpers, grammar extensions are all about *how* something is plotted using composable visualisation elements. These extension functions directly add to the ggplot2 grammar with new geometries, statistics, coordinates, scales, themes and/or more. The key advantage of directly extending the grammar is that the added functionality can be used to create any number of plots in combination with other grammar elements (including from other extension packages).\n\n<!-- Design difficulties - modular design -->\nGrammar extensions can be more difficult to implement than plot helper functions, since they involve understanding the inner workings or ggplot2^[The [*Extending ggplot2*](https://ggplot2.tidyverse.org/articles/extending-ggplot2.html) vignette is a good place to start learning the ggproto extension system.] rather than simply how ggplot2 is used. Designing grammar extensions also require an understanding of how various plot elements work together. Well designed grammar extension functions are highly modular, making them compatible with other plot elements from ggplot2 and extension packages. This composable grammar-based design is what allows ggplot2 to create any number of plots by reusing grammar elements in different ways.\n\n<!-- Similar design problems with helper plots -->\n<!-- * Trying to do too much, ending up with less modular and less re-usable design -->\n<!-- * geom/stat -->\n\nGrammar extensions often have the opposite design problems as plot helper functions. In attempts to be more helpful and easy to use, grammar extensions compound multiple elements of the grammar. This makes the extensions less modular and reusable in creating other plots. This is commonly seen in the design of geometries (`geom_*()`) and statistics (`stat_*()`), which are coupled together in ggplot2 as layers. An example of this is `geom_histogram()`, which is actually a `geom_bar()`^[Further than that, `geom_bar()` is a special case of `geom_rect()`.] with a `stat_bin()` statistic[^piecharts]. This *helpful* histogram 'geometry' is less reusable as a modular component in other plots, and potentially adds confusion between similar geometries. Creating histograms as binned bar charts invites thinking about other geometries which could show binned counts, or how other statistics can be used to show proportions instead of counts.\n\n[^piecharts]: This is also why we don't have a `geom_piechart()`, since it would involve both a bar geometry and polar coordinate elements.\n\n<!-- Maybe add something about pie charts relating to bars in polar coordinates -->\n\n## Design story of forecast visualisation\n\n\n<!-- ### Conclude comparison -->\n\n<!-- * Designing useful graphics functions with ggplot2  -->\n\n<!-- Comparison with plot helpers -->\n<!-- * Both are useful for different purposes -->\n\nIn my package design experience, I find that the best plot helpers are simple/helpful for creating a specific plot, and ggplot2 extensions are modular/flexible as a single element in a wider grammar.\n\n<!-- Modular/flexible <> Helpful/simple -->\n### Helpful plots for forecast visualisation\n\nWhen creating new plotting functions I often start with creating plot helpers, using existing ggplot2 elements and data pre-processing to construct a new plot which is somewhat complicated to create directly with ggplot2. An example of this is when I created an `autoplot()` function^[`autoplot()` is a ggplot2 function for creating plot helpers for a specific object class.] for the forecast package's forecast plots.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(forecast)\nwine_fc <- hw(wineind, h=48)\nautoplot(wine_fc)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/forecastplot-1.png){width=672}\n:::\n:::\n\n\n<!-- * my experience from wrapper to extension and back to wrapper. -->\nThis `autoplot()` method originally re-organised a `forecast` object into a data frame for plotting, and used a carefully constructed ribbon geometry (`geom_ribbon()`) to layer the forecast intervals atop one another (along with `geom_line()` for the point forecast).\n\n### New plot elements for forecast uncertainty\n\nThis plot helper function met the needs for visualising forecasts for a while, but eventually came the need for visualising forecasts in different ways with different styles. Rather than adding additional arguments options for `autoplot.forecast()` to create completely different plots in with different visual appearance, I instead created a modular forecast geometry `geom_forecast()` which can be used to create any plot. I also created a forecast statistic, `stat_forecast()`, to also calculate forecasts by default much like `geom_smooth()` calculates a smooth line through the data^[As mentioned earlier with `geom_histogram()` I think more separation between geometry and statistic is a better design than what I previously created with `geom_forecast()`.].\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nwineind |> \n  ggplot(aes(x=x, y=y)) + \n  geom_line() + \n  geom_forecast(h = 48)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/forecastgeom-1.png){width=672}\n:::\n:::\n\n\nAfter creating `geom_forecast()` ggplot2 extension, I then was able to vastly simplify the plot helper's code by using this new forecast geometry. This approach of creating both plot helpers and ggplot2 extensions allows for both:\n\n1. A quick and simple plot helper function for looking at data in an analysis.\n2. A flexible and modular ggplot2 extension that is reusable to create many plots with different structure and style.\n\n### Iterated improvements in visualising uncertainty\n\n<!-- Current design, ggdist and distributional -->\nSeveral incremental design and implementation improvements have been made for visualising forecasts since first creating the plot helpers and grammar extensions described above. The fable package^[The tidy/rectangular successor to the forecast package.] for forecasting still offers the same quick and easy `autoplot()` function for plotting forecasts:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tsibble)\nlibrary(fable)\nwine_tsbl <- as_tsibble(wineind)\nwine_fbl <- wine_tsbl |> \n  model(ETS(value)) |> \n  forecast(h = 48)\nwine_fbl |> \n  autoplot(wine_tsbl)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fableplot-1.png){width=672}\n:::\n:::\n\n\nHowever the visualisation of forecasts is now built up with smaller and more modular components. In particular, the forecast object (a *fable*) is now rectangular and ready to use directly with ggplot2 and other tidy/rectangular functions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwine_fbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A fable: 48 x 4 [1M]\n# Key:     .model [1]\n   .model        index             value  .mean\n   <chr>         <mth>            <dist>  <dbl>\n 1 ETS(value) 1994 Sep N(24739, 4756552) 24739.\n 2 ETS(value) 1994 Oct N(26972, 5674061) 26972.\n 3 ETS(value) 1994 Nov N(31771, 7901147) 31771.\n 4 ETS(value) 1994 Dec N(37060, 1.1e+07) 37060.\n 5 ETS(value) 1995 Jan N(16590, 2169674) 16590.\n 6 ETS(value) 1995 Feb N(21206, 3557682) 21206.\n 7 ETS(value) 1995 Mar N(23948, 4553053) 23948.\n 8 ETS(value) 1995 Apr N(25620, 5229329) 25620.\n 9 ETS(value) 1995 May N(24054, 4625845) 24054.\n10 ETS(value) 1995 Jun N(24662, 4880015) 24662.\n# i 38 more rows\n```\n\n\n:::\n:::\n\n\nMost importantly is that the forecasts are represented with distributions (via the [distributional](https://pkg.mitchelloharawild.com/distributional/) package), which can be directly visualised with ggplot2 (via the [ggdist](https://mjskay.github.io/ggdist/) package). The ggdist package provides several statistics (`stat_*()`) which allow you to use distributions in ggplot2 via the `dist` argument.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggdist)\nwine_fbl |>  \n  ggplot(aes(x = index)) + \n  # Past data\n  geom_line(aes(y = value), data = wine_tsbl) + \n  # Forecasts\n  stat_lineribbon(aes(dist = value, fill_ramp = after_stat(.width)), \n                  fill = \"steelblue\", colour = \"steelblue\",\n                  linewidth = 0.4, .width = c(0.8, 0.95)) +\n  scale_fill_ramp_continuous(limits = c(0.7, 1), range = c(1, 0))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ggdist-1.png){width=672}\n:::\n:::\n\n\nIt is more complicated to create this plot since it requires decisions than you might expect - colours, scales, sizing and more. However thinking about visualising distributions with modular grammar components also allows you to switch out geometries to visualise forecasts differently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(wine_fbl, 12) |> \n  ggplot(aes(x = index)) + \n  # Past data\n  geom_line(aes(y = value), data = tail(wine_tsbl, 36)) + \n  # Forecasts\n  stat_halfeye(aes(dist = value), size = 0.5, \n               colour = \"steelblue\", fill = \"#82c3f2\") + \n  geom_line(aes(y = .mean), colour = \"steelblue\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/ggdist-alt-1.png){width=672}\n:::\n:::\n\n\nVisualising distributions with ggdist are not limited to forecasting, and by designing extensions to be more modular (and consequently, do less) they can be reused more widely. \n\n## Conclusion\n\nWhile creating, learning and using grammar elements is harder than plot helper functions, they allow you to create more visually beautiful and analytically useful graphics. Good design of these grammar elements enables their reusability in making any style of plot for any purpose.\n\nPlot helpers can't possibly create the perfect visualisation for your analysis - and they shouldn't try to^[I'm pleased to see others take on this belief in these great Stack Overflow answers: <https://stackoverflow.com/questions/78512507/stop-fabletools-autoplot-from-using-color-aesthetic-for-models-when-faceting>]. Attempts to make helper functions do more make them harder to learn and use^[This is especially evident in Cynthia Huang's comparison of [three calendar plot helper variants](https://www.cynthiahqy.com/posts/ggplot-wrapper-design/#same-same-but-very-different-variation-in-helper-interfaces)]. To keep plot helper functions simple, I refuse to add extra options for changing the style of the plot even if it is easy to do so.\n\n<!-- For more bespoke visualisation it is better to directly use ggplot2 and think more about the plot elements that best suit your needs. -->",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}