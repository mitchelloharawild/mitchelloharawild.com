{
  "hash": "1b4346cc3ffd11e9fb85ae2abe59cd47",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Arranging hex stickers in R\ndescription: 'Features magick to create the purrr-fect hex layout'\nauthor: Mitchell O'Hara-Wild\ndate: '2018-07-10'\ncategories:\n  - magick\n  - purrr\ntags:\n  - hexagon\n  - sticker\n  - wall\n  - design\nfeature: 'hexwall.png'\nfeature_alt: 'Example hexwall'\nfreeze: true\n---\n\n\n\n\nNeatly aligning hex stickers for presentations or reports is a tedious process. It is repetitive, and very easy to get wrong. Despite the physical hexagons having a standardised shape and size, digital hexagons appear in many forms. With variation in file type, resolution, transparency and layouts, working with hexagon files can prove challenging.\n\nThe code in this blog is bundled into the hexwall R script (available at [mitchelloharawild/hexwall](https://github.com/mitchelloharawild/hexwall)), making it simpler to arrange your stickers.\n\nMy need for this functionality began with the creation of a hex sticker feature wall at [useR! 2018](http://user2018.r-project.org/). This involved arranging approximately 200 stickers in the shape of Australia, which you can read about in [this blog post](https://blog.mitchelloharawild.com/blog/user-2018-feature-wall).\n\nIn that project we collected the stickers via email, but for this blog we will use the RStudio hex-stickers from their GitHub repository ([rstudio/hex-stickers](https://github.com/rstudio/hex-stickers)).\n\nI've picked out a few hex stickers from this repository and placed the png images from the PNG folder in a `hex-stickers` folder.\n\n## Preparation\nBefore we start aligning the hexagons, we first need to convert them to a common size and format. In most cases, the conversion can be done automatically with the [ROpenSci magick package](https://github.com/ropensci/magick).\n\nAll images can be read with `image_read`, however better quality for svg and png formats can be obtained using their specific reading functions. As many stickers had white backgrounds (especially pdf format images), I first convert white to transparent, and then use `image_trim` to automatically crop the images.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(magick)\nlibrary(purrr)\n\nsticker_files <- list.files(\"hex-stickers\", full.names = TRUE)\nstickers <- sticker_files %>% \n  map(compose(image_read, ~ image_transparent(., \"white\"), image_trim, .dir = \"forward\")) %>%\n  set_names(basename(sticker_files))\n```\n:::\n\n\nUnfortunately some stickers can not be fixed automatically, as they were either too low resolution or incorrectly shaped. These cases are easily identifiable for manual fixing from the image information provided by `image_info()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Desired sticker resolution in pixels\nsticker_width <- 121\n\n# Scale all stickers to the desired pixel width\nstickers <- stickers %>%\n  map(image_scale, sticker_width)\n  \n# Identify low resolution stickers\nstickers %>%\n  map_lgl(~ with(\n    image_info(.x),\n    width < (sticker_width-1)/2 && format != \"svg\"\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   forcats.png   ggplot2.png      pipe.png     purrr.png tidyverse.png \n#>         FALSE         FALSE         FALSE         FALSE         FALSE\n```\n\n\n:::\n\n```{.r .cell-code}\n# Identify incorrect shapes / proportions (tolerance of +-2 height)\nstickers %>%\n  map_lgl(~ with(\n    image_info(.x),\n    height < (median(height)-2) | height > (median(height) + 2)\n  ))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#>   forcats.png   ggplot2.png      pipe.png     purrr.png tidyverse.png \n#>         FALSE         FALSE         FALSE         FALSE         FALSE\n```\n\n\n:::\n:::\n\n\nAs some stickers may have slightly different proportions (wihin tolerances above), we first force the stickers to have identical dimensions for alignment.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extract correct sticker height (this could also be calculated directly from width)\nsticker_height <- stickers %>%\n  map(image_info) %>%\n  map_dbl(\"height\") %>%\n  median\n\n# Coerce sticker dimensions\nstickers <- stickers %>%\n  map(image_resize, paste0(sticker_width, \"x\", sticker_height, \"!\"))\n\nstickers[[\"tidyverse.png\"]]\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/resize-1.png){width=60}\n:::\n:::\n\n\n## Alignment\nUsing magick, it is relatively trivial to align hexagons into rows using magick's `image_append()` functionality. The total hexagons in each row alternates between odd and even numbers.\n\n::: {.cell}\n\n```{.r .cell-code}\nsticker_row_size <- 3\n# Calculate row sizes\nsticker_col_size <- ceiling(length(stickers)/(sticker_row_size-0.5))\nrow_lens <- rep(c(sticker_row_size,sticker_row_size-1), length.out=sticker_col_size)\nrow_lens[length(row_lens)] <- row_lens[length(row_lens)]  - (length(stickers) - sum(row_lens))\n\nsticker_rows <- map2(row_lens, cumsum(row_lens),\n                     ~ seq(.y-.x+1, by = 1, length.out = .x)) %>%\n  map(~ stickers[.x] %>%\n        invoke(c, .) %>%\n        image_append)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n#> Warning: `invoke()` was deprecated in purrr 1.0.0.\n#> i Please use `exec()` instead.\n```\n\n\n:::\n\n```{.r .cell-code}\nsticker_rows[[1]]\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/rows-1.png){width=182}\n:::\n:::\n\n\nTo simplify the placement of these sticker rows, we can first create a white canvas for us to place sticker rows on. The width is simple to calculate, but the height is slightly more complex. The extra height of each row is the height of the left side of the hexagon (approximately `sticker_height/1.33526`), then to add the angled parts of the hexagon for the top and bottom, we add the height of one whole sticker.\n\n::: {.cell}\n\n```{.r .cell-code}\n# Add stickers to canvas\ncanvas <- image_blank(sticker_row_size*sticker_width, \n                      sticker_height + (sticker_col_size-1)*sticker_height/1.33526,\n                      \"white\")\n```\n:::\n\n\nWith our canvas and list of sticker_rows, it is time to add them to the final image using `image_composite`. The offset of the rows is calculated from the current row number (..3), which is used to add the current row (..2) to the canvas (..1).\n\n::: {.cell}\n\n```{.r .cell-code}\nreduce2(sticker_rows, seq_along(sticker_rows), \n        ~ image_composite(\n          ..1, ..2,\n          offset = paste0(\"+\", ((..3-1)%%2)*sticker_width/2,\n                          \"+\", round((..3-1)*sticker_height/1.33526))\n        ),\n        .init = canvas)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/final-1.png){width=182}\n:::\n:::\n\n\n## hexwall\n\nNow that you know how it works, try it out on your own hexagon stickers. You can use the code above, or the script available on Github ([mitchelloharawild/hexwall](https://github.com/mitchelloharawild/hexwall)). To use the hexwall script on this example, you would use the hexwall function like this:\n\n::: {.cell}\n\n```{.r .cell-code}\nsource(\"hexwall.R\")\nhexwall(\"path\", sticker_row_size = 9, sticker_width = 121)\n```\n:::",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}