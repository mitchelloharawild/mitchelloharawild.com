{
  "hash": "4cd58bbf268282715e39cdd6b1e46c12",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Loading R packages in a loop\ndescription: 'Non-standard evaluation with the library function'\ndate: '2018-07-04'\nslug: loading-r-packages-in-a-loop\ncategories:\n  - nse\ntags:\n  - library\n  - package\n  - loop\nfeature: 'pkg_loop.png'\nfeature_alt: 'Example NSE problem'\n---\n\n\n\n\nIn Nick Tierney ([\\@nj_tierney](https://twitter.com/nj_tierney)) and Saskia Freytag's ([\\@trashystats](https://twitter.com/trashystats)) second Credibly Curious [podcast](https://soundcloud.com/crediblycurious/2-episode-the-tidyverse), they briefly delve into the confusing world of non-standard evaluation (NSE). As part of this discussion, podcast guest Roger Peng ([\\@rdpeng](https://twitter.com/rdpeng)) noted that:\n\n> If you really want have fun, try loading packages in a loop\n\nAlthough not a pop-quiz, it is certainly a challenge, and a common cause of confusion for R users.\n\nMost R users would load packages using the library function, such as `library(tidyverse)`. So to load packages in a loop, one might try:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npackages <- c(\"ggplot2\", \"dplyr\")\nfor(pkg in packages){\n  library(pkg)\n}\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in library(pkg): there is no package called 'pkg'\n```\n\n\n:::\n:::\n\n\nIf it were that simple, it wouldn't warrant a blog post! This doesn't work because the library function uses non-standard evaluation. That is what allows you to use `library(tidyverse)` instead of `library(\"tidyverse\")`. In the loop, R tries to be helpful by loading `pkg` instead of the value stored inside (\"ggplot2\", and then \"dplyr\").\n\n## What is non-standard evaluation?\n\nFor most R users, an understanding of non-standard evaluation (NSE) is rarely needed. You may not know what non-standard evaluation is, but you have definitely used it before (perhaps without even realising). In fact, NSE is used each time you load in a package without quoting the package name.\n\nMost tidyverse packages also leverage NSE to simplify the typing needed to transform a dataset or plot some data. Try to identify the NSE parts in the following code examples:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\nmtcars %>%\n  mutate(displ_l = disp / 61.0237)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(ggplot2)\nggplot(mtcars, aes(wt, mpg)) +\n  geom_point()\n```\n:::\n\n\nSo what is non-standard evaluation? As the name may suggest, it is code which is evaluated in a non-standard way. As an example, let's look at the dplyr code above. The mutate function is calculating `disp / 61.0237` and saving the result as a column called displ_l. Standard evaluation in R would find the disp variable and compute the division, so let's try that:\n\n::: {.cell}\n\n```{.r .cell-code}\ndisp / 61.0237\n```\n\n::: {.cell-output .cell-output-error}\n\n```\n#> Error in eval(expr, envir, enclos): object 'disp' not found\n```\n\n\n:::\n:::\n\n\nR is unable to find the disp variable because it exists as a column in the mtcars dataset, not in the evaluation environment. When using this code in the mutate function, dplyr helpfully prevents evaluation, and later re-evaluates by first looking in the provided data, and then in the evaluation environment. So when this code is used in the mutate function, R is now able to find disp, because dplyr has changed where R looks for the variable.\n\n::: {.cell}\n\n```{.r .cell-code}\nmtcars %>%\n  mutate(displ_l = disp / 61.0237)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n\n\n|              |  mpg| cyl| disp|  hp| drat|    wt|  qsec| vs| am| gear| carb|  displ_l|\n|:-------------|----:|---:|----:|---:|----:|-----:|-----:|--:|--:|----:|----:|--------:|\n|Mazda RX4     | 21.0|   6|  160| 110| 3.90| 2.620| 16.46|  0|  1|    4|    4| 2.621932|\n|Mazda RX4 Wag | 21.0|   6|  160| 110| 3.90| 2.875| 17.02|  0|  1|    4|    4| 2.621932|\n|Datsun 710    | 22.8|   4|  108|  93| 3.85| 2.320| 18.61|  1|  1|    4|    1| 1.769804|\n\n\n:::\n:::\n\n\nFor more details on non-standard evaluation, I recommend reading the [Advanced R book](http://adv-r.had.co.nz/Computing-on-the-language.html).\n\n## Using NSE to load packages in a loop\n\nSo, now with a brief understanding of NSE, let's try to use the library function in a loop again. Remember, the issue is that library uses non-standard evaluation on package names, so we can't use `library(pkg)`. Instead, we need to use NSE ourselves to substitute pkg with the name of the package itself, as if you had written it directly into the console. To achieve this, we need to build an expression, which is simply code which has not yet been evaluated. \n\nThere are many different ways to do this, but I will suggest two similar methods: one using base R, and one using the tidyverse.\n\nIn base, you can replace values in an expression using `bquote()` and `.()` to create the desired expression.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npkg <- \"ggplot2\"\nbquote(library(.(pkg)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> library(\"ggplot2\")\n```\n\n\n:::\n:::\n\n\nUsing rlang, we can achieve a similar result using `expr()` and `!!` to replace the `pkg` with the actual variable.\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rlang)\npkg <- \"ggplot2\"\nexpr(library(!!pkg))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n#> library(\"ggplot2\")\n```\n\n\n:::\n:::\n\n\nAll that is left is to evaluate these expressions using `eval` or `eval_tidy` in a loop, which will run the code and load the packages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Base\nfor(pkg in c(\"ggplot2\", \"dplyr\")){\n  eval(bquote(library(.(pkg))))\n}\n\n# Tidy\nlibrary(purrr)\nlibrary(rlang)\nc(\"ggplot2\", \"dplyr\") %>%\n  map(~ eval_tidy(expr(library(!!.x))))\n```\n:::\n\n\n## Alternatively...\nYou could also set `character.only = TRUE` which prevents the use of non-standard evaluation. But if I started with that, I wouldn't have a good excuse to talk about the wonders of non-standard evaluation!\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# With a for loop\nfor(pkg in c(\"ggplot2\", \"dplyr\")){\n  library(pkg, character.only = TRUE)\n}\n\n# Or with functional programming\nmap(c(\"ggplot2\", \"dplyr\"), library, character.only = TRUE)\n```\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}